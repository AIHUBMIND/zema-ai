# Zema AI Personal Assistant - Cursor AI Rules

## Project Overview
- This is Zema AI Personal Assistant - privacy-first voice assistant
- Runs on mini PC (BOSGAME P3 Lite) with Ubuntu 22.04
- Uses Ollama for local LLM inference (Llama 13B) - 100% offline
- Built with Python 3.11+, FastAPI, async/await
- GitHub Repository: https://github.com/AIHUBMIND/zema-ai.git

## Code Style
- Follow PEP 8 Python style guide
- Use type hints for all functions
- Prefer async/await over sync code
- Use Pydantic for data validation
- Use docstrings for all public functions and classes

## Architecture Principles
- Smart Hybrid Mode: Automatically detects Internet connectivity and switches between online services (preferred) and local LLM (fallback)
- Offline-first: All core features work without internet using local LLM as fallback
- Privacy-first: All data stored locally when offline; online data usage is configurable
- Modular: Each module has single responsibility
- Async-first: Use async/await for I/O operations

## Project Structure
- `src/core/` - Core orchestrator, state management
- `src/config/` - Configuration management (Pydantic)
- `src/voice/` - Voice I/O, wake word, STT, TTS
- `src/vision/` - Camera, vision processing
- `src/ai/` - LLM client, context management
- `src/tools/` - Personal assistant tools
- `src/api/` - FastAPI server, routes
- `src/utils/` - Utilities, logging, helpers

## Best Practices
- Use structured logging with structlog
- Handle errors gracefully with proper exception handling
- Validate all inputs with Pydantic models
- Keep functions small and focused
- Write tests for critical functionality
- Document public APIs

## Dependencies
- FastAPI for web API
- Pydantic for validation
- SQLAlchemy for database
- PyAudio for audio I/O
- OpenCV for vision processing
- Faster Whisper for STT
- Ollama for LLM inference (local)

## Git Workflow & Auto-Commit (CRITICAL)

### After Completing Every Task
**CRITICAL RULE:** After completing ANY task, feature, or change, you MUST:
1. Run the auto-commit script: `python scripts/auto_commit.py "task description"`
2. Use descriptive task descriptions (e.g., "Added configuration system", "Implemented voice module")
3. The script will automatically:
   - Stage all changes (`git add .`)
   - Create commit with formatted message (`feat: task description - timestamp`)
   - Push to GitHub (`origin/main` → https://github.com/AIHUBMIND/zema-ai.git)

### Auto-Commit Command Format
```bash
python scripts/auto_commit.py "brief task description"
```

Examples:
- `python scripts/auto_commit.py "Added configuration system"`
- `python scripts/auto_commit.py "Implemented voice module"`
- `python scripts/auto_commit.py "Fixed bug in API endpoint"`
- `python scripts/auto_commit.py "Updated documentation"`

### Commit Message Format
The script automatically formats messages as:
- `feat: task description - YYYY-MM-DD HH:MM:SS`

### Task Completion Checklist
When finishing any task, ALWAYS:
- [ ] Code is complete and tested
- [ ] Follows project style guidelines
- [ ] Documentation updated if needed
- [ ] **Run auto-commit:** `python scripts/auto_commit.py "task description"`
- [ ] Verify push to GitHub was successful

### Manual Commit (if auto-commit fails)
If the auto-commit script fails, use manual commands:
```bash
git add .
git commit -m "feat: task description"
git push origin main
```

### Never Commit
- `.env` files (contains secrets)
- `venv/` folder (virtual environment)
- `__pycache__/` directories
- `*.log` files
- `data/db/*.db` files (database files)

## Workflow Example
1. User asks: "Add configuration system"
2. You implement the feature
3. Code is complete
4. **You MUST run:** `python scripts/auto_commit.py "Added configuration system"`
5. Changes are automatically committed and pushed to GitHub
6. Task is complete

## Documentation & Progress Tracking (CRITICAL)

### After Completing Every Task
**CRITICAL RULE:** After completing ANY task, you MUST:
1. Update documentation: `python scripts/maintenance/update_docs.py "Task Name" TASK-ID complete`
2. Verify progress tracking files are updated:
   - `docs/progress/CHECKPOINT.md` - Quick resume point
   - `docs/progress/PROJECT_PROGRESS.md` - Detailed progress
   - `docs/architecture/CODE_DOCUMENTATION.md` - Code documentation (if new code added)

### Documentation File Management (CRITICAL)
**NEVER CREATE NEW MARKDOWN FILES UNLESS ABSOLUTELY NECESSARY**

**RULE:** Always append/update existing files instead of creating new ones:
- ✅ **APPEND** to existing documentation files
- ✅ **UPDATE** existing sections in files
- ✅ **CHECK** if similar information exists before creating
- ❌ **DO NOT** create new .md files for similar content
- ❌ **DO NOT** duplicate information across files

**Use these existing files:**
- Progress updates → `docs/progress/PROJECT_PROGRESS.md` (append to "Recent Changes Log")
- Code documentation → `docs/architecture/CODE_DOCUMENTATION.md` (append new sections)
- Architecture changes → `docs/architecture/ARCHITECTURE.md` (update sections)
- Setup notes → `docs/setup/` (update appropriate existing file)
- Git workflow → `docs/git/` (update appropriate existing file)
- Structure info → `docs/README.md` (update structure section)

**Only create new files if:**
- It's a completely new category that doesn't exist
- It's a new guide from `docs/guides/` folder
- It's a new hardware-specific documentation

**Before creating any .md file:**
1. Check if similar information exists in existing files
2. If yes, append/update that file instead
3. If no, confirm it's truly a new category before creating

### Resuming Work in New Chat
**When user says "go" or "continue":**
1. Read `docs/progress/CHECKPOINT.md` to find last completed task
2. Read `docs/progress/PROJECT_PROGRESS.md` for detailed status
3. Read `docs/guides/ZEMA-CURSOR-PROMPTS.md` for next prompt
4. Execute the next prompt automatically
5. Update all documentation files
6. Commit changes

### Documentation Files
- `docs/progress/CHECKPOINT.md` - Quick resume point (always check this first)
- `docs/progress/PROJECT_PROGRESS.md` - Master progress tracker
- `docs/architecture/CODE_DOCUMENTATION.md` - Detailed file-by-file documentation
- `docs/architecture/ARCHITECTURE.md` - System architecture documentation

## Auto-Documentation Rule (CRITICAL)

### When Creating New Python Files
**CRITICAL RULE:** Whenever a new Python file is created, you MUST:
1. Create corresponding documentation file in `docs/` folder mirroring the same structure
2. Documentation file path: `docs/{same_path_as_python_file}.md`
3. Example: `src/voice/audio_io.py` → `docs/src/voice/audio_io.md`

### Documentation Template
Each new Python file documentation MUST include:
- **File Location**: Path to the Python file
- **Purpose**: What the file does
- **Why It Was Created**: Context and reasoning
- **How It Works**: Detailed explanation of functionality
- **Dependencies**: Required libraries/modules
- **Usage**: How to use it with examples
- **Integration**: How it fits into the project

### Auto-Documentation Process
1. **Create Python file** in appropriate location
2. **Create documentation file** in `docs/` following same path structure
3. **Write comprehensive documentation** using the template above
4. **Update folder README.md** if the folder's purpose changes
5. **Verify documentation** matches the code structure

### Folder Documentation
When creating new folders:
- Create `docs/{folder_path}/README.md` explaining:
  - What the folder contains
  - Purpose of the folder
  - How files work together
  - Key concepts

### Documentation Checklist
After creating any Python file:
- [ ] Created corresponding `.md` file in `docs/` mirroring path structure
- [ ] Documentation includes all required sections (Purpose, Why Created, How It Works, etc.)
- [ ] Updated folder `README.md` if needed
- [ ] Documentation follows existing documentation style
- [ ] Code examples included where relevant

### Examples
**Creating `src/voice/wakeword.py`:**
1. Create `docs/src/voice/wakeword.md`
2. Include all required sections
3. Update `docs/src/voice/README.md` if needed

**Creating `scripts/maintenance/new_script.py`:**
1. Create `docs/scripts/maintenance/new_script.md`
2. Include all required sections
3. Update `docs/scripts/maintenance/README.md` if needed

### Auto-Documentation Helper Script
Use `scripts/maintenance/create_doc.py` to generate documentation template:
```bash
python scripts/maintenance/create_doc.py src/voice/wakeword.py
```
This will:
- Parse the Python file
- Extract classes, functions, imports
- Generate documentation template in `docs/src/voice/wakeword.md`
- Fill in TODO sections that need manual completion

## Compliance Checking & Documentation Updates (CRITICAL)

### After Completing Every Task
**CRITICAL RULE:** After completing ANY task, feature, or change, you MUST:

1. **Run compliance check:** `python scripts/maintenance/check_rules_compliance.py`
   - Verifies code follows all .cursorrules requirements
   - Checks for type hints, docstrings, project structure
   - Identifies any violations

2. **Fix any compliance issues** before proceeding

3. **Update documentation** using `scripts/maintenance/update_docs.py`:
   ```bash
   python scripts/maintenance/update_docs.py "Task Name" TASK-ID complete
   ```

4. **Verify documentation files are updated:**
   - `docs/progress/CHECKPOINT.md` - Quick resume point
   - `docs/progress/PROJECT_PROGRESS.md` - Detailed progress
   - `docs/architecture/CODE_DOCUMENTATION.md` - Code documentation (if new code added)
   - `docs/architecture/ARCHITECTURE.md` - Architecture changes (if architecture changed)

5. **Run auto-commit:** `python scripts/maintenance/auto_commit.py "task description"`

### Compliance Check Command
```bash
# Run compliance check
python scripts/maintenance/check_rules_compliance.py

# This checks:
# - Project structure (all required directories exist)
# - Python code style (type hints, docstrings)
# - Dependencies (requirements.txt)
# - Git workflow (auto_commit.py exists)
```

### Documentation Update Command
```bash
# Update documentation after task completion
python scripts/maintenance/update_docs.py "Task Name" TASK-ID complete

# Examples:
python scripts/maintenance/update_docs.py "SETUP-001" SETUP-001 complete
python scripts/maintenance/update_docs.py "Smart Hybrid Mode" ARCH-001 complete
```

### Complete Task Completion Workflow
When finishing any task, ALWAYS follow this sequence:

1. [ ] Code is complete and tested
2. [ ] Follows project style guidelines
3. [ ] **Run compliance check:** `python scripts/maintenance/check_rules_compliance.py`
4. [ ] Fix any compliance violations found
5. [ ] **Update documentation:** `python scripts/maintenance/update_docs.py "Task Name" TASK-ID complete`
6. [ ] Verify documentation files updated (CHECKPOINT.md, PROJECT_PROGRESS.md, etc.)
7. [ ] **Run auto-commit:** `python scripts/maintenance/auto_commit.py "task description"`
8. [ ] Verify push to GitHub was successful

### Why This Matters
- **Compliance checks** ensure code quality and consistency
- **Documentation updates** keep progress tracking accurate
- **Auto-commit** ensures changes are saved to GitHub
- All three steps together maintain project integrity

### Example Complete Workflow
```bash
# 1. Complete task (e.g., update architecture)
# ... make changes ...

# 2. Run compliance check
python scripts/maintenance/check_rules_compliance.py

# 3. Fix any issues found

# 4. Update documentation
python scripts/maintenance/update_docs.py "Smart Hybrid Mode Architecture" ARCH-001 complete

# 5. Commit and push
python scripts/maintenance/auto_commit.py "Updated architecture for Smart Hybrid Mode"
```

This ensures every task completion:
- ✅ Code is compliant with rules
- ✅ Documentation is up-to-date
- ✅ Changes are committed to GitHub
